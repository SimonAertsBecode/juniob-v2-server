// Juniob V2 - Prisma Schema
// Junior Developer Pre-Screening Platform with Two-Tier AI Analysis

generator client {
  provider = "prisma-client-js"
  output   = "./generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// ENUMS
// ============================================

enum UserRole {
  DEVELOPER
  COMPANY
}

enum AssessmentStatus {
  REGISTERING // Account created but profile incomplete
  PROJECTS_SUBMITTED // Projects submitted, waiting for analysis
  ANALYZING // Tier 1 analysis in progress
  PENDING_ANALYSIS // Developer modified/deleted project, needs regeneration
  ASSESSED // All analyses complete, hiring report generated
}

enum ProjectType {
  FRONTEND
  BACKEND
  FULLSTACK
  MOBILE
  OTHER
}

enum ProjectAnalysisStatus {
  PENDING // Waiting to be analyzed
  ANALYZING // Analysis in progress
  COMPLETE // Analysis finished successfully
  FAILED // Analysis failed
}

enum PipelineStage {
  INVITED // Company sent invitation
  REGISTERING // Developer started signup
  PROJECTS_SUBMITTED // Projects submitted for analysis
  ANALYZING // Analysis in progress
  PENDING_ANALYSIS // Needs report regeneration
  ASSESSED // Assessment complete
  UNLOCKED // Company unlocked the report
  HIRED // Candidate was hired
  REJECTED // Candidate was rejected
}

enum CreditTransactionType {
  INITIAL // 3 free credits on registration
  PURCHASE // Bought credits via Stripe
  UNLOCK_REPORT // Spent 1 credit to unlock developer report
}

enum HireRecommendation {
  SAFE_TO_INTERVIEW // Solid fundamentals, safe to proceed
  INTERVIEW_WITH_CAUTION // Has potential but notable concerns to probe
  NOT_READY // Too many fundamental gaps for professional environment
}

enum JuniorLevel {
  ABOVE_EXPECTED // Exceeds typical junior level (top 10-15%)
  WITHIN_EXPECTED // Meets expectations for a junior
  BELOW_EXPECTED // Below typical junior level
}

enum DeveloperType {
  FRONTEND
  BACKEND
  FULLSTACK
  MOBILE
}

// ============================================
// USER MODEL (Unified Authentication)
// ============================================

model User {
  id                     Int       @id @default(autoincrement())
  email                  String    @unique
  hashedPassword         String
  hashedRefreshToken     String?
  role                   UserRole

  // Email verification
  emailVerified          Boolean   @default(false)
  emailVerificationToken String?

  // Password reset
  passwordResetToken     String?
  passwordResetExpiresAt DateTime?

  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  // Relations - one-to-one with role-specific profiles
  developer              Developer?
  company                Company?

  @@index([email])
}

// ============================================
// COMPANY MODELS
// ============================================

model Company {
  id     Int  @id @default(autoincrement())
  userId Int  @unique

  // Company info
  name     String
  industry String?
  size     String? // e.g., "1-10", "11-50", "51-200", etc.
  location String?
  website  String?

  // Billing info
  vatNumber        String?
  billingAddress   String?
  billingCountry   String?
  stripeCustomerId String?

  // Settings
  emailNotifications Boolean @default(true)

  // Credits
  creditBalance Int @default(3) // Start with 3 free credits

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user               User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  creditTransactions CreditTransaction[]
  pipelineEntries    PipelineEntry[]
  unlockedReports    UnlockedReport[]
  tags               Tag[]

  @@index([userId])
}

// ============================================
// DEVELOPER MODELS
// ============================================

model Developer {
  id     Int  @id @default(autoincrement())
  userId Int  @unique

  // Basic profile info
  firstName String?
  lastName  String?
  location  String?

  // Assessment status
  assessmentStatus AssessmentStatus @default(REGISTERING)

  // Visibility to companies (default true, developer can opt-out anytime)
  isVisible Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  projects            TechnicalProject[]
  hiringReport        HiringReport?
  pipelineEntries     PipelineEntry[]
  unlockedBy          UnlockedReport[]
  githubInstallations GithubAppInstallation[]
  technicalProfile    TechnicalProfile? // One-to-one: technical specialization and experiences

  @@index([userId])
  @@index([assessmentStatus])
}

// Technical profile: developer type and tech experiences
// Separated from basic profile for cleaner data organization
model TechnicalProfile {
  id            Int           @id @default(autoincrement())
  developerId   Int           @unique
  developerType DeveloperType // FRONTEND, BACKEND, FULLSTACK, MOBILE

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  developer       Developer        @relation(fields: [developerId], references: [id], onDelete: Cascade)
  techExperiences TechExperience[]

  @@index([developerId])
}

// Developer's experience per technology stack
// Used to calibrate AI analysis based on experience level
model TechExperience {
  id                 Int    @id @default(autoincrement())
  technicalProfileId Int
  stackName          String // e.g., "React.js", "Node.js", "TypeScript"
  months             Int // Experience in months (e.g., 4 = 4 months, 24 = 2 years)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  technicalProfile TechnicalProfile @relation(fields: [technicalProfileId], references: [id], onDelete: Cascade)

  @@unique([technicalProfileId, stackName]) // One entry per stack per technical profile
  @@index([technicalProfileId])
}

// ============================================
// GITHUB APP INTEGRATION
// ============================================

model GithubAppInstallation {
  id                   String    @id @default(uuid())
  developerId          Int
  installationId       String // GitHub App installation ID
  accessTokenEncrypted String? // AES-256-CBC encrypted token
  tokenExpiresAt       DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  developer    Developer             @relation(fields: [developerId], references: [id], onDelete: Cascade)
  repositories GithubAppRepository[]

  @@unique([developerId, installationId])
  @@index([developerId])
}

model GithubAppRepository {
  id             String  @id @default(uuid())
  installationId String
  githubRepoId   BigInt // GitHub's repository ID
  repoName       String // e.g., "my-project"
  repoFullName   String // e.g., "username/my-project"
  description    String?
  isPrivate      Boolean

  createdAt DateTime @default(now())

  // Relations
  installation GithubAppInstallation @relation(fields: [installationId], references: [id], onDelete: Cascade)

  @@unique([installationId, githubRepoId])
  @@index([installationId])
  @@index([repoFullName])
}

// ============================================
// TECHNICAL ASSESSMENT - TWO-TIER AI SYSTEM
// ============================================

// Developer's GitHub project (max 3 per developer)
model TechnicalProject {
  id          Int @id @default(autoincrement())
  developerId Int

  // Project info
  name        String // Display name (editable by dev)
  githubUrl   String
  projectType ProjectType
  description String?
  uiUrl       String? // Optional live demo/website URL

  // Tech stack detected
  techStack String[] // e.g., ["React", "TypeScript", "Node.js"]

  // Lock system - 30 days minimum after analysis
  savedAt     DateTime? // When project was saved/analyzed
  lockedUntil DateTime? // savedAt + 30 days

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  developer Developer        @relation(fields: [developerId], references: [id], onDelete: Cascade)
  analysis  ProjectAnalysis? // Tier 1 analysis

  @@index([developerId])
}

// Tier 1: Individual Project Analysis (DEVELOPER CAN SEE)
model ProjectAnalysis {
  id        Int @id @default(autoincrement())
  projectId Int @unique

  // Analysis status
  status ProjectAnalysisStatus @default(PENDING)

  // Score
  score Int? // 0-100

  // Analysis results (developer can see these)
  strengths           String[] // What the developer did well
  areasForImprovement String[] // Constructive feedback for growth
  codeOrganization    String? // Assessment of code structure
  bestPractices       String[] // Best practices followed

  // Raw analysis (for debugging/reference)
  rawAnalysis Json?

  // Error handling
  errorMessage String? // If analysis failed
  retryCount   Int     @default(0)

  // Timestamps
  startedAt   DateTime?
  completedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  project TechnicalProject @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([status])
}

// Tier 2: Aggregate Hiring Report (COMPANY VIEW ONLY - after unlock)
model HiringReport {
  id          Int @id @default(autoincrement())
  developerId Int @unique

  // PRIMARY DECISION SIGNAL - Hiring Recommendation
  recommendation        HireRecommendation // SAFE_TO_INTERVIEW, INTERVIEW_WITH_CAUTION, NOT_READY
  recommendationReasons String[] // 3-5 bullet points explaining why

  // Junior Level Benchmark
  juniorLevel        JuniorLevel // ABOVE_EXPECTED, WITHIN_EXPECTED, BELOW_EXPECTED
  juniorLevelContext String? // e.g., "Junior Frontend", "Junior Backend", "Junior Full-Stack"

  // Technical Skill Breakdown (4 sections)
  // { codeStructure: {summary, strengths, improvements}, coreFundamentals: {...}, problemSolving: {...}, toolingPractices: {...} }
  technicalBreakdown Json?

  // Risk Flags / Points of Attention
  riskFlags String[] // Potential risks that could cause surprises after hiring

  // Authenticity & Confidence Signal
  authenticitySignal      String? // HIGH, MEDIUM, LOW
  authenticityExplanation String? // Brief explanation of signals observed

  // Interview Guidance
  interviewQuestions String[] // 3-5 specific questions based on weak areas, risk flags

  // Technical Confidence Score (SECONDARY - supports qualitative evaluation)
  overallScore Int // 0-100 (internal comparison score)
  scoreBand    String? // STRONG_JUNIOR, AVERAGE_JUNIOR, RISKY_JUNIOR

  // Summary Conclusion
  conclusion String // 2-3 sentence summary answering: Should we interview this person and why?

  // Additional guidance (optional)
  techProficiency Json? // e.g., {"React": 7, "Node.js": 5, "TypeScript": 6}
  mentoringNeeds  String[] // What support this dev needs
  growthPotential String? // Assessment of learning trajectory

  // Raw analysis (for debugging)
  rawAnalysis Json?

  generatedAt DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  developer Developer @relation(fields: [developerId], references: [id], onDelete: Cascade)

  @@index([recommendation])
}

// ============================================
// CREDIT SYSTEM
// ============================================

model CreditTransaction {
  id        Int                   @id @default(autoincrement())
  companyId Int
  type      CreditTransactionType

  // Transaction details
  amount       Int // Positive for purchases, negative for unlocks
  balanceAfter Int // Credit balance after this transaction

  // Metadata
  description String? // e.g., "Unlocked report for john@example.com"

  // For PURCHASE type - Stripe info
  stripePaymentIntentId String?
  stripeSessionId       String?

  // For UNLOCK_REPORT type - which developer was unlocked
  unlockedDeveloperId Int?

  createdAt DateTime @default(now())

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([type])
  @@index([createdAt])
}

// Track which companies have unlocked which developers
model UnlockedReport {
  id          Int @id @default(autoincrement())
  companyId   Int
  developerId Int

  unlockedAt DateTime @default(now())

  // Relations
  company   Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  developer Developer @relation(fields: [developerId], references: [id], onDelete: Cascade)

  @@unique([companyId, developerId]) // Each company can only unlock once per developer
  @@index([companyId])
  @@index([developerId])
}

// ============================================
// PIPELINE & TRACKING
// ============================================

model PipelineEntry {
  id          Int  @id @default(autoincrement())
  companyId   Int
  developerId Int? // NOW OPTIONAL - null for unregistered candidates

  // For unregistered candidates (invitation data)
  candidateEmail    String?   // Email when developerId is null
  invitationToken   String?   @unique @default(uuid())
  invitationMessage String?   // Personal message from company
  invitedAt         DateTime? // When invitation was sent
  tokenExpiresAt    DateTime? // Token expiration (7 days)

  stage PipelineStage @default(INVITED)

  // Notes (company can add private notes about candidate)
  notes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  company   Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  developer Developer?         @relation(fields: [developerId], references: [id], onDelete: Cascade)
  tags      PipelineEntryTag[]

  @@unique([companyId, developerId]) // One entry per company-developer pair
  @@unique([companyId, candidateEmail]) // One entry per company-email pair
  @@index([companyId])
  @@index([developerId])
  @@index([candidateEmail])
  @@index([invitationToken])
  @@index([stage])
}

// ============================================
// TAGS (Labels for organizing pipeline entries)
// ============================================

model Tag {
  id        Int    @id @default(autoincrement())
  companyId Int
  name      String // e.g., "Frontend", "Senior", "Project-X"
  color     String // Hex color for UI, e.g., "#3B82F6"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  company         Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  pipelineEntries PipelineEntryTag[]

  @@unique([companyId, name]) // Each company can only have one tag with a given name
  @@index([companyId])
}

model PipelineEntryTag {
  id              Int @id @default(autoincrement())
  pipelineEntryId Int
  tagId           Int

  createdAt DateTime @default(now())

  // Relations
  pipelineEntry PipelineEntry @relation(fields: [pipelineEntryId], references: [id], onDelete: Cascade)
  tag           Tag           @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([pipelineEntryId, tagId]) // A tag can only be assigned once per pipeline entry
  @@index([pipelineEntryId])
  @@index([tagId])
}
